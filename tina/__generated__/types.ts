//@ts-nocheck
// DO NOT MODIFY THIS FILE. This file is automatically generated by Tina
export function gql(strings: TemplateStringsArray, ...args: string[]): string {
  let str = "";
  strings.forEach((string, i) => {
    str += string + (args[i] || "");
  });
  return str;
}
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = {
  [K in keyof T]: T[K];
};
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]?: Maybe<T[SubKey]>;
};
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]: Maybe<T[SubKey]>;
};
export type MakeEmpty<
  T extends { [key: string]: unknown },
  K extends keyof T
> = { [_ in K]?: never };
export type Incremental<T> =
  | T
  | {
      [P in keyof T]?: P extends " $fragmentName" | "__typename" ? T[P] : never;
    };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string };
  String: { input: string; output: string };
  Boolean: { input: boolean; output: boolean };
  Int: { input: number; output: number };
  Float: { input: number; output: number };
  /** References another document, used as a foreign key */
  Reference: { input: any; output: any };
  JSON: { input: any; output: any };
};

export type SystemInfo = {
  __typename?: "SystemInfo";
  filename: Scalars["String"]["output"];
  title?: Maybe<Scalars["String"]["output"]>;
  basename: Scalars["String"]["output"];
  hasReferences?: Maybe<Scalars["Boolean"]["output"]>;
  breadcrumbs: Array<Scalars["String"]["output"]>;
  path: Scalars["String"]["output"];
  relativePath: Scalars["String"]["output"];
  extension: Scalars["String"]["output"];
  template: Scalars["String"]["output"];
  collection: Collection;
};

export type SystemInfoBreadcrumbsArgs = {
  excludeExtension?: InputMaybe<Scalars["Boolean"]["input"]>;
};

export type Folder = {
  __typename?: "Folder";
  name: Scalars["String"]["output"];
  path: Scalars["String"]["output"];
};

export type PageInfo = {
  __typename?: "PageInfo";
  hasPreviousPage: Scalars["Boolean"]["output"];
  hasNextPage: Scalars["Boolean"]["output"];
  startCursor: Scalars["String"]["output"];
  endCursor: Scalars["String"]["output"];
};

export type Node = {
  id: Scalars["ID"]["output"];
};

export type Document = {
  id: Scalars["ID"]["output"];
  _sys?: Maybe<SystemInfo>;
  _values: Scalars["JSON"]["output"];
};

/** A relay-compliant pagination connection */
export type Connection = {
  totalCount: Scalars["Float"]["output"];
  pageInfo: PageInfo;
};

export type Query = {
  __typename?: "Query";
  getOptimizedQuery?: Maybe<Scalars["String"]["output"]>;
  collection: Collection;
  collections: Array<Collection>;
  node: Node;
  document: DocumentNode;
  nft: Nft;
  nftConnection: NftConnection;
  artist: Artist;
  artistConnection: ArtistConnection;
};

export type QueryGetOptimizedQueryArgs = {
  queryString: Scalars["String"]["input"];
};

export type QueryCollectionArgs = {
  collection?: InputMaybe<Scalars["String"]["input"]>;
};

export type QueryNodeArgs = {
  id?: InputMaybe<Scalars["String"]["input"]>;
};

export type QueryDocumentArgs = {
  collection?: InputMaybe<Scalars["String"]["input"]>;
  relativePath?: InputMaybe<Scalars["String"]["input"]>;
};

export type QueryNftArgs = {
  relativePath?: InputMaybe<Scalars["String"]["input"]>;
};

export type QueryNftConnectionArgs = {
  before?: InputMaybe<Scalars["String"]["input"]>;
  after?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Float"]["input"]>;
  last?: InputMaybe<Scalars["Float"]["input"]>;
  sort?: InputMaybe<Scalars["String"]["input"]>;
  filter?: InputMaybe<NftFilter>;
};

export type QueryArtistArgs = {
  relativePath?: InputMaybe<Scalars["String"]["input"]>;
};

export type QueryArtistConnectionArgs = {
  before?: InputMaybe<Scalars["String"]["input"]>;
  after?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Float"]["input"]>;
  last?: InputMaybe<Scalars["Float"]["input"]>;
  sort?: InputMaybe<Scalars["String"]["input"]>;
  filter?: InputMaybe<ArtistFilter>;
};

export type DocumentFilter = {
  nft?: InputMaybe<NftFilter>;
  artist?: InputMaybe<ArtistFilter>;
};

export type DocumentConnectionEdges = {
  __typename?: "DocumentConnectionEdges";
  cursor: Scalars["String"]["output"];
  node?: Maybe<DocumentNode>;
};

export type DocumentConnection = Connection & {
  __typename?: "DocumentConnection";
  pageInfo: PageInfo;
  totalCount: Scalars["Float"]["output"];
  edges?: Maybe<Array<Maybe<DocumentConnectionEdges>>>;
};

export type Collection = {
  __typename?: "Collection";
  name: Scalars["String"]["output"];
  slug: Scalars["String"]["output"];
  label?: Maybe<Scalars["String"]["output"]>;
  path: Scalars["String"]["output"];
  format?: Maybe<Scalars["String"]["output"]>;
  matches?: Maybe<Scalars["String"]["output"]>;
  templates?: Maybe<Array<Maybe<Scalars["JSON"]["output"]>>>;
  fields?: Maybe<Array<Maybe<Scalars["JSON"]["output"]>>>;
  documents: DocumentConnection;
};

export type CollectionDocumentsArgs = {
  before?: InputMaybe<Scalars["String"]["input"]>;
  after?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Float"]["input"]>;
  last?: InputMaybe<Scalars["Float"]["input"]>;
  sort?: InputMaybe<Scalars["String"]["input"]>;
  filter?: InputMaybe<DocumentFilter>;
  folder?: InputMaybe<Scalars["String"]["input"]>;
};

export type DocumentNode = Nft | Artist | Folder;

export type NftArtist = Artist;

export type Nft = Node &
  Document & {
    __typename?: "Nft";
    title: Scalars["String"]["output"];
    artist: NftArtist;
    price: Scalars["Float"]["output"];
    image_ipfs: Scalars["String"]["output"];
    thumbnail_ipfs?: Maybe<Scalars["String"]["output"]>;
    is_listed?: Maybe<Scalars["Boolean"]["output"]>;
    category?: Maybe<Scalars["String"]["output"]>;
    body?: Maybe<Scalars["JSON"]["output"]>;
    id: Scalars["ID"]["output"];
    _sys: SystemInfo;
    _values: Scalars["JSON"]["output"];
  };

export type StringFilter = {
  startsWith?: InputMaybe<Scalars["String"]["input"]>;
  eq?: InputMaybe<Scalars["String"]["input"]>;
  exists?: InputMaybe<Scalars["Boolean"]["input"]>;
  in?: InputMaybe<Array<InputMaybe<Scalars["String"]["input"]>>>;
};

export type NftArtistFilter = {
  artist?: InputMaybe<ArtistFilter>;
};

export type NumberFilter = {
  lt?: InputMaybe<Scalars["Float"]["input"]>;
  lte?: InputMaybe<Scalars["Float"]["input"]>;
  gte?: InputMaybe<Scalars["Float"]["input"]>;
  gt?: InputMaybe<Scalars["Float"]["input"]>;
  eq?: InputMaybe<Scalars["Float"]["input"]>;
  exists?: InputMaybe<Scalars["Boolean"]["input"]>;
  in?: InputMaybe<Array<InputMaybe<Scalars["Float"]["input"]>>>;
};

export type BooleanFilter = {
  eq?: InputMaybe<Scalars["Boolean"]["input"]>;
  exists?: InputMaybe<Scalars["Boolean"]["input"]>;
};

export type RichTextFilter = {
  startsWith?: InputMaybe<Scalars["String"]["input"]>;
  eq?: InputMaybe<Scalars["String"]["input"]>;
  exists?: InputMaybe<Scalars["Boolean"]["input"]>;
};

export type NftFilter = {
  title?: InputMaybe<StringFilter>;
  artist?: InputMaybe<NftArtistFilter>;
  price?: InputMaybe<NumberFilter>;
  image_ipfs?: InputMaybe<StringFilter>;
  thumbnail_ipfs?: InputMaybe<StringFilter>;
  is_listed?: InputMaybe<BooleanFilter>;
  category?: InputMaybe<StringFilter>;
  body?: InputMaybe<RichTextFilter>;
};

export type NftConnectionEdges = {
  __typename?: "NftConnectionEdges";
  cursor: Scalars["String"]["output"];
  node?: Maybe<Nft>;
};

export type NftConnection = Connection & {
  __typename?: "NftConnection";
  pageInfo: PageInfo;
  totalCount: Scalars["Float"]["output"];
  edges?: Maybe<Array<Maybe<NftConnectionEdges>>>;
};

export type Artist = Node &
  Document & {
    __typename?: "Artist";
    name: Scalars["String"]["output"];
    slug: Scalars["String"]["output"];
    avatar?: Maybe<Scalars["String"]["output"]>;
    bio_short?: Maybe<Scalars["String"]["output"]>;
    website?: Maybe<Scalars["String"]["output"]>;
    twitter?: Maybe<Scalars["String"]["output"]>;
    instagram?: Maybe<Scalars["String"]["output"]>;
    body?: Maybe<Scalars["JSON"]["output"]>;
    id: Scalars["ID"]["output"];
    _sys: SystemInfo;
    _values: Scalars["JSON"]["output"];
  };

export type ImageFilter = {
  startsWith?: InputMaybe<Scalars["String"]["input"]>;
  eq?: InputMaybe<Scalars["String"]["input"]>;
  exists?: InputMaybe<Scalars["Boolean"]["input"]>;
  in?: InputMaybe<Array<InputMaybe<Scalars["String"]["input"]>>>;
};

export type ArtistFilter = {
  name?: InputMaybe<StringFilter>;
  slug?: InputMaybe<StringFilter>;
  avatar?: InputMaybe<ImageFilter>;
  bio_short?: InputMaybe<StringFilter>;
  website?: InputMaybe<StringFilter>;
  twitter?: InputMaybe<StringFilter>;
  instagram?: InputMaybe<StringFilter>;
  body?: InputMaybe<RichTextFilter>;
};

export type ArtistConnectionEdges = {
  __typename?: "ArtistConnectionEdges";
  cursor: Scalars["String"]["output"];
  node?: Maybe<Artist>;
};

export type ArtistConnection = Connection & {
  __typename?: "ArtistConnection";
  pageInfo: PageInfo;
  totalCount: Scalars["Float"]["output"];
  edges?: Maybe<Array<Maybe<ArtistConnectionEdges>>>;
};

export type Mutation = {
  __typename?: "Mutation";
  addPendingDocument: DocumentNode;
  updateDocument: DocumentNode;
  deleteDocument: DocumentNode;
  createDocument: DocumentNode;
  createFolder: DocumentNode;
  updateNft: Nft;
  createNft: Nft;
  updateArtist: Artist;
  createArtist: Artist;
};

export type MutationAddPendingDocumentArgs = {
  collection: Scalars["String"]["input"];
  relativePath: Scalars["String"]["input"];
  template?: InputMaybe<Scalars["String"]["input"]>;
};

export type MutationUpdateDocumentArgs = {
  collection?: InputMaybe<Scalars["String"]["input"]>;
  relativePath: Scalars["String"]["input"];
  params: DocumentUpdateMutation;
};

export type MutationDeleteDocumentArgs = {
  collection?: InputMaybe<Scalars["String"]["input"]>;
  relativePath: Scalars["String"]["input"];
};

export type MutationCreateDocumentArgs = {
  collection?: InputMaybe<Scalars["String"]["input"]>;
  relativePath: Scalars["String"]["input"];
  params: DocumentMutation;
};

export type MutationCreateFolderArgs = {
  collection?: InputMaybe<Scalars["String"]["input"]>;
  relativePath: Scalars["String"]["input"];
};

export type MutationUpdateNftArgs = {
  relativePath: Scalars["String"]["input"];
  params: NftMutation;
};

export type MutationCreateNftArgs = {
  relativePath: Scalars["String"]["input"];
  params: NftMutation;
};

export type MutationUpdateArtistArgs = {
  relativePath: Scalars["String"]["input"];
  params: ArtistMutation;
};

export type MutationCreateArtistArgs = {
  relativePath: Scalars["String"]["input"];
  params: ArtistMutation;
};

export type DocumentUpdateMutation = {
  nft?: InputMaybe<NftMutation>;
  artist?: InputMaybe<ArtistMutation>;
  relativePath?: InputMaybe<Scalars["String"]["input"]>;
};

export type DocumentMutation = {
  nft?: InputMaybe<NftMutation>;
  artist?: InputMaybe<ArtistMutation>;
};

export type NftMutation = {
  title?: InputMaybe<Scalars["String"]["input"]>;
  artist?: InputMaybe<Scalars["String"]["input"]>;
  price?: InputMaybe<Scalars["Float"]["input"]>;
  image_ipfs?: InputMaybe<Scalars["String"]["input"]>;
  thumbnail_ipfs?: InputMaybe<Scalars["String"]["input"]>;
  is_listed?: InputMaybe<Scalars["Boolean"]["input"]>;
  category?: InputMaybe<Scalars["String"]["input"]>;
  body?: InputMaybe<Scalars["JSON"]["input"]>;
};

export type ArtistMutation = {
  name?: InputMaybe<Scalars["String"]["input"]>;
  slug?: InputMaybe<Scalars["String"]["input"]>;
  avatar?: InputMaybe<Scalars["String"]["input"]>;
  bio_short?: InputMaybe<Scalars["String"]["input"]>;
  website?: InputMaybe<Scalars["String"]["input"]>;
  twitter?: InputMaybe<Scalars["String"]["input"]>;
  instagram?: InputMaybe<Scalars["String"]["input"]>;
  body?: InputMaybe<Scalars["JSON"]["input"]>;
};

export type NftPartsFragment = {
  __typename: "Nft";
  title: string;
  price: number;
  image_ipfs: string;
  thumbnail_ipfs?: string | null;
  is_listed?: boolean | null;
  category?: string | null;
  body?: any | null;
  artist: {
    __typename: "Artist";
    name: string;
    slug: string;
    avatar?: string | null;
    bio_short?: string | null;
    website?: string | null;
    twitter?: string | null;
    instagram?: string | null;
    body?: any | null;
    id: string;
    _sys: {
      __typename?: "SystemInfo";
      filename: string;
      basename: string;
      hasReferences?: boolean | null;
      breadcrumbs: Array<string>;
      path: string;
      relativePath: string;
      extension: string;
    };
  };
};

export type ArtistPartsFragment = {
  __typename: "Artist";
  name: string;
  slug: string;
  avatar?: string | null;
  bio_short?: string | null;
  website?: string | null;
  twitter?: string | null;
  instagram?: string | null;
  body?: any | null;
};

export type NftQueryVariables = Exact<{
  relativePath: Scalars["String"]["input"];
}>;

export type NftQuery = {
  __typename?: "Query";
  nft: {
    __typename: "Nft";
    id: string;
    title: string;
    price: number;
    image_ipfs: string;
    thumbnail_ipfs?: string | null;
    is_listed?: boolean | null;
    category?: string | null;
    body?: any | null;
    _sys: {
      __typename?: "SystemInfo";
      filename: string;
      basename: string;
      hasReferences?: boolean | null;
      breadcrumbs: Array<string>;
      path: string;
      relativePath: string;
      extension: string;
    };
    artist: {
      __typename: "Artist";
      name: string;
      slug: string;
      avatar?: string | null;
      bio_short?: string | null;
      website?: string | null;
      twitter?: string | null;
      instagram?: string | null;
      body?: any | null;
      id: string;
      _sys: {
        __typename?: "SystemInfo";
        filename: string;
        basename: string;
        hasReferences?: boolean | null;
        breadcrumbs: Array<string>;
        path: string;
        relativePath: string;
        extension: string;
      };
    };
  };
};

export type NftConnectionQueryVariables = Exact<{
  before?: InputMaybe<Scalars["String"]["input"]>;
  after?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Float"]["input"]>;
  last?: InputMaybe<Scalars["Float"]["input"]>;
  sort?: InputMaybe<Scalars["String"]["input"]>;
  filter?: InputMaybe<NftFilter>;
}>;

export type NftConnectionQuery = {
  __typename?: "Query";
  nftConnection: {
    __typename?: "NftConnection";
    totalCount: number;
    pageInfo: {
      __typename?: "PageInfo";
      hasPreviousPage: boolean;
      hasNextPage: boolean;
      startCursor: string;
      endCursor: string;
    };
    edges?: Array<{
      __typename?: "NftConnectionEdges";
      cursor: string;
      node?: {
        __typename: "Nft";
        id: string;
        title: string;
        price: number;
        image_ipfs: string;
        thumbnail_ipfs?: string | null;
        is_listed?: boolean | null;
        category?: string | null;
        body?: any | null;
        _sys: {
          __typename?: "SystemInfo";
          filename: string;
          basename: string;
          hasReferences?: boolean | null;
          breadcrumbs: Array<string>;
          path: string;
          relativePath: string;
          extension: string;
        };
        artist: {
          __typename: "Artist";
          name: string;
          slug: string;
          avatar?: string | null;
          bio_short?: string | null;
          website?: string | null;
          twitter?: string | null;
          instagram?: string | null;
          body?: any | null;
          id: string;
          _sys: {
            __typename?: "SystemInfo";
            filename: string;
            basename: string;
            hasReferences?: boolean | null;
            breadcrumbs: Array<string>;
            path: string;
            relativePath: string;
            extension: string;
          };
        };
      } | null;
    } | null> | null;
  };
};

export type ArtistQueryVariables = Exact<{
  relativePath: Scalars["String"]["input"];
}>;

export type ArtistQuery = {
  __typename?: "Query";
  artist: {
    __typename: "Artist";
    id: string;
    name: string;
    slug: string;
    avatar?: string | null;
    bio_short?: string | null;
    website?: string | null;
    twitter?: string | null;
    instagram?: string | null;
    body?: any | null;
    _sys: {
      __typename?: "SystemInfo";
      filename: string;
      basename: string;
      hasReferences?: boolean | null;
      breadcrumbs: Array<string>;
      path: string;
      relativePath: string;
      extension: string;
    };
  };
};

export type ArtistConnectionQueryVariables = Exact<{
  before?: InputMaybe<Scalars["String"]["input"]>;
  after?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Float"]["input"]>;
  last?: InputMaybe<Scalars["Float"]["input"]>;
  sort?: InputMaybe<Scalars["String"]["input"]>;
  filter?: InputMaybe<ArtistFilter>;
}>;

export type ArtistConnectionQuery = {
  __typename?: "Query";
  artistConnection: {
    __typename?: "ArtistConnection";
    totalCount: number;
    pageInfo: {
      __typename?: "PageInfo";
      hasPreviousPage: boolean;
      hasNextPage: boolean;
      startCursor: string;
      endCursor: string;
    };
    edges?: Array<{
      __typename?: "ArtistConnectionEdges";
      cursor: string;
      node?: {
        __typename: "Artist";
        id: string;
        name: string;
        slug: string;
        avatar?: string | null;
        bio_short?: string | null;
        website?: string | null;
        twitter?: string | null;
        instagram?: string | null;
        body?: any | null;
        _sys: {
          __typename?: "SystemInfo";
          filename: string;
          basename: string;
          hasReferences?: boolean | null;
          breadcrumbs: Array<string>;
          path: string;
          relativePath: string;
          extension: string;
        };
      } | null;
    } | null> | null;
  };
};

export const NftPartsFragmentDoc = gql`
  fragment NftParts on Nft {
    __typename
    title
    artist {
      ... on Artist {
        __typename
        name
        slug
        avatar
        bio_short
        website
        twitter
        instagram
        body
      }
      ... on Document {
        _sys {
          filename
          basename
          hasReferences
          breadcrumbs
          path
          relativePath
          extension
        }
        id
      }
    }
    price
    image_ipfs
    thumbnail_ipfs
    is_listed
    category
    body
  }
`;
export const ArtistPartsFragmentDoc = gql`
  fragment ArtistParts on Artist {
    __typename
    name
    slug
    avatar
    bio_short
    website
    twitter
    instagram
    body
  }
`;
export const NftDocument = gql`
  query nft($relativePath: String!) {
    nft(relativePath: $relativePath) {
      ... on Document {
        _sys {
          filename
          basename
          hasReferences
          breadcrumbs
          path
          relativePath
          extension
        }
        id
      }
      ...NftParts
    }
  }
  ${NftPartsFragmentDoc}
`;
export const NftConnectionDocument = gql`
  query nftConnection(
    $before: String
    $after: String
    $first: Float
    $last: Float
    $sort: String
    $filter: NftFilter
  ) {
    nftConnection(
      before: $before
      after: $after
      first: $first
      last: $last
      sort: $sort
      filter: $filter
    ) {
      pageInfo {
        hasPreviousPage
        hasNextPage
        startCursor
        endCursor
      }
      totalCount
      edges {
        cursor
        node {
          ... on Document {
            _sys {
              filename
              basename
              hasReferences
              breadcrumbs
              path
              relativePath
              extension
            }
            id
          }
          ...NftParts
        }
      }
    }
  }
  ${NftPartsFragmentDoc}
`;
export const ArtistDocument = gql`
  query artist($relativePath: String!) {
    artist(relativePath: $relativePath) {
      ... on Document {
        _sys {
          filename
          basename
          hasReferences
          breadcrumbs
          path
          relativePath
          extension
        }
        id
      }
      ...ArtistParts
    }
  }
  ${ArtistPartsFragmentDoc}
`;
export const ArtistConnectionDocument = gql`
  query artistConnection(
    $before: String
    $after: String
    $first: Float
    $last: Float
    $sort: String
    $filter: ArtistFilter
  ) {
    artistConnection(
      before: $before
      after: $after
      first: $first
      last: $last
      sort: $sort
      filter: $filter
    ) {
      pageInfo {
        hasPreviousPage
        hasNextPage
        startCursor
        endCursor
      }
      totalCount
      edges {
        cursor
        node {
          ... on Document {
            _sys {
              filename
              basename
              hasReferences
              breadcrumbs
              path
              relativePath
              extension
            }
            id
          }
          ...ArtistParts
        }
      }
    }
  }
  ${ArtistPartsFragmentDoc}
`;
export type Requester<C = {}> = <R, V>(
  doc: DocumentNode,
  vars?: V,
  options?: C
) => Promise<R>;
export function getSdk<C>(requester: Requester<C>) {
  return {
    nft(
      variables: NftQueryVariables,
      options?: C
    ): Promise<{
      data: NftQuery;
      errors?: {
        message: string;
        locations: { line: number; column: number }[];
        path: string[];
      }[];
      variables: NftQueryVariables;
      query: string;
    }> {
      return requester<
        {
          data: NftQuery;
          errors?: {
            message: string;
            locations: { line: number; column: number }[];
            path: string[];
          }[];
          variables: NftQueryVariables;
          query: string;
        },
        NftQueryVariables
      >(NftDocument, variables, options);
    },
    nftConnection(
      variables?: NftConnectionQueryVariables,
      options?: C
    ): Promise<{
      data: NftConnectionQuery;
      errors?: {
        message: string;
        locations: { line: number; column: number }[];
        path: string[];
      }[];
      variables: NftConnectionQueryVariables;
      query: string;
    }> {
      return requester<
        {
          data: NftConnectionQuery;
          errors?: {
            message: string;
            locations: { line: number; column: number }[];
            path: string[];
          }[];
          variables: NftConnectionQueryVariables;
          query: string;
        },
        NftConnectionQueryVariables
      >(NftConnectionDocument, variables, options);
    },
    artist(
      variables: ArtistQueryVariables,
      options?: C
    ): Promise<{
      data: ArtistQuery;
      errors?: {
        message: string;
        locations: { line: number; column: number }[];
        path: string[];
      }[];
      variables: ArtistQueryVariables;
      query: string;
    }> {
      return requester<
        {
          data: ArtistQuery;
          errors?: {
            message: string;
            locations: { line: number; column: number }[];
            path: string[];
          }[];
          variables: ArtistQueryVariables;
          query: string;
        },
        ArtistQueryVariables
      >(ArtistDocument, variables, options);
    },
    artistConnection(
      variables?: ArtistConnectionQueryVariables,
      options?: C
    ): Promise<{
      data: ArtistConnectionQuery;
      errors?: {
        message: string;
        locations: { line: number; column: number }[];
        path: string[];
      }[];
      variables: ArtistConnectionQueryVariables;
      query: string;
    }> {
      return requester<
        {
          data: ArtistConnectionQuery;
          errors?: {
            message: string;
            locations: { line: number; column: number }[];
            path: string[];
          }[];
          variables: ArtistConnectionQueryVariables;
          query: string;
        },
        ArtistConnectionQueryVariables
      >(ArtistConnectionDocument, variables, options);
    },
  };
}
export type Sdk = ReturnType<typeof getSdk>;

// TinaSDK generated code
import { createClient, TinaClient } from "tinacms/dist/client";

const generateRequester = (client: TinaClient) => {
  const requester: (
    doc: any,
    vars?: any,
    options?: {
      branch?: string;
      /**
       * Aside from `method` and `body`, all fetch options are passed
       * through to underlying fetch request
       */
      fetchOptions?: Omit<Parameters<typeof fetch>[1], "body" | "method">;
    },
    client
  ) => Promise<any> = async (doc, vars, options) => {
    let url = client.apiUrl;
    if (options?.branch) {
      const index = client.apiUrl.lastIndexOf("/");
      url = client.apiUrl.substring(0, index + 1) + options.branch;
    }
    const data = await client.request(
      {
        query: doc,
        variables: vars,
        url,
      },
      options
    );

    return {
      data: data?.data,
      errors: data?.errors,
      query: doc,
      variables: vars || {},
    };
  };

  return requester;
};

/**
 * @experimental this class can be used but may change in the future
 **/
export const ExperimentalGetTinaClient = () =>
  getSdk(
    generateRequester(
      createClient({
        url: "http://localhost:4001/graphql",
        queries,
      })
    )
  );

export const queries = (client: TinaClient) => {
  const requester = generateRequester(client);
  return getSdk(requester);
};
